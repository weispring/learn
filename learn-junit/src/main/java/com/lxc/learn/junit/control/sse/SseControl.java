package com.lxc.learn.junit.control.sse;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Date;
import java.util.Random;

/**
 * SSE(Server-Sent Events):通俗解释起来就是一种基于HTTP的，以流的形式由服务端持续向客户端发送数据的技术
 *
 * 在http1.1中(1.0也有但未写入标准),虽然增加了keep-alive来保持和服务器的长连接,省去了很多建立连接的过程,但通信过程仍然是应答式1:1的方式，也就是想要获得数据，就必须先发送一个request才能得到一个response,所以在实时监控、推送、视频直播等实时性较高或者带宽利用较苛刻的场景，仍然不是很合适
 * SSE技术由于能保持连接，并持续接收服务端的数据，所以弥补了这一缺点,与其他类似技术方案相比，短轮询、Coment、WebSocket，在大多数时候，SSE仍然是最好的选择
 *
 * @Auther: lixianchun
 * @Date: 2019/12/2 22:30
 * @Description:
 */
@Slf4j
@RestController
public class SseControl {

    /**
     * 1.若是control return ,则tomcat容器会关闭http连接
     * 2.sse推送的报文格式
     * 3.正确的响应客户端，
     * TODO WARN
     * 问题：
     * 1.sse是否是全部输出完，客户端才能获取结果？
     * 不用，每次写完需要flush
     *
     * 2.什么情况服务器关闭连接，如何在服务器服务端主动手动关闭连接？
     * emitter.complete();不使用emitter，如何关闭呢
     *
     * 3.什么情况会自动重连？
     * @param request
     * @return
     */

    @RequestMapping(value = "push",produces = {"text/event-stream"})
    public Object sse(HttpServletRequest request){
        Random r = new Random();
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "data:Testing 1,2,3" + r.nextInt() +"\n\n";
    }

    /**
     * 手写 sse
     *
     * @param request
     * @param response
     * @throws Exception
     */
    @RequestMapping(value = "pushPrefect",produces = {"text/event-stream"})
    public void ssePrefect(HttpServletRequest request, HttpServletResponse response) throws Exception{
        Random r = new Random();
        Long start = System.currentTimeMillis();

        response.setContentType("text/event-stream");
        response.setCharacterEncoding("utf-8");

        String resp = "As shown in the figure that follows, the query example was first executed in the Visual SQL editor. Next, an Explain report was generated by clicking Query and then Explain Current Statement from the menu. The initial report shows a Visual Explain image with information that appears when you move your pointer device over the orders table in full table scan.";
        while (true){
            byte[] bytes = ("data:"+System.currentTimeMillis()+"\r\n").getBytes();
            try {
                response.getWriter().write("retry: "+2000+"\n");
                response.getWriter().write(": this is a test stream\n\n");
                response.getWriter().write("data: "+System.currentTimeMillis()+"\r\n");
                //此处必要，否则无法实时输出
                response.flushBuffer();
                Thread.sleep(1000);

                //客户端断开，则退出循环
                if(response.getWriter().checkError()){
                    log.info("客户端断开连接");
                    return;
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
            if (System.currentTimeMillis() - start > 6000){
                response.getOutputStream().close();
                break;
            }
        }
        //response.getOutputStream().flush();
      /*  String resp = "data:Testing 1,2,3" + r.nextInt() +"\n\n";
        response.getOutputStream().write(resp.getBytes());*/
    }

}
