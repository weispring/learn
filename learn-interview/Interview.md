1.为什么子类重写父类的方法的访问修饰符，不能低于父类的方法访问权限？
重写也叫覆写，修饰符、返回类型、参数就是要和父类一摸一样才叫覆写，意思是说各个地方都需要完美的盖住，在面向接口编程中，重写是子类有自己的逻辑要实现，同时又不破坏已写好程序逻辑的好方法
举个例子，在父类中是public的方法，如果子类中将其降低访问权限为private，那么子类中重写以后的方法对于外部对象就不可访问了，这个就破坏了继承的含义。

2.synchronized

3.正则表达式”\d+\.?\d*”的意义是？
\d+ 表示可以出现1次或是n次数字
\.? 表示可以“.”可以出现一次，也可以不出现
\d* 表示可以出现0次或是n次数字

4.mysql如何避免更新覆盖呢？
1.乐观锁，version。
2.悲观锁
解决方案1（悲观锁）
a.传统的悲观锁法（不推荐）：
在弹出修改工资的页面初始化时（这种情况下一般会去从数据库查询出来），在这个初始化查询中使用select ...for update nowait
通过添加for update nowait语句，将这条记录锁住，避免其他用户更新，从而保证后续的更新是在正确的状态下更新的。
然后在保持这个链接的状态下，在做更新提交。当然这个有个前提就是要保持链接，就是要对链接要占用较长时间，这个在现在web系统高并发高频率下显然是不现实的。
  
b.现在的悲观锁法（推荐优先使用）：
在修改工资这个页面做提交时先查询下，当然这个查询必须也要加锁（select ...for update nowait），有人会说，
在这里做个查询确认记录是否有改变不就行了吗，是的，是要做个确认，只是你不加for update就不能保证你在查询到更新提交这段时间里这条记录没有被其他会话更新过，
所以这种方式也需要在查询时锁定记录，保证在这条记录没有变化的基础上再做更新，若有变化则提示告知用户。
页面做提交时先加锁查询下,不要一开始就加锁，增加效率。

解决方案2（乐观锁）
a.旧值条件（前镜像）法：
就是在sql更新时使用旧的状态值做条件，SQL大致如下 Update table set col1 =newcol1value, col2 = newcol2value….
where col1 =oldcol1value and col2 = oldcol2value….，在上面的例子中我们就可以把当前工资作为条件进行更新，
如果这条记录已经被其他会话更新过，则本次更新了0行，这里我们应用系统一般会做个提示告知用户重新查询更新。
这个取哪些旧值作为条件更新视具体系统实际情况而定。（这种方式有可能发生阻塞，
如果应用其他地方使用悲观锁法长时间锁定了这条记录，则本次会话就需要等待，所以使用这种方式时最好统一使用乐观锁法。）

b.使用版本列法（推荐优先使用）：
其实这种方式是一个特殊化的前镜像法，就是不需要使用多个旧值做条件，只需要在表上加一个版本列，这一列可以是NUMBER或DATE/TIMESTAMP列，加这列的作用就是用来记录这条数据的版本（在表设计时一般我们都会给每个表增加一些NUMBER型和DATE型的冗余字段，以便扩展使用，这些冗余字段完全可以作为版本列用），在应用程序中我们每次操作对版本列做维护即可。在更新时我们把上次版本作为条件进行更新。


[]分布式事物的实现方式？


[]库存如何回滚？


spring中bean的作用范围？
singleton	在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。
prototype	每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。
request	每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。
session	同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。
application	限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。


