1.为什么子类重写父类的方法的访问修饰符，不能低于父类的方法访问权限？
重写也叫覆写，修饰符、返回类型、参数就是要和父类一摸一样才叫覆写，意思是说各个地方都需要完美的盖住，在面向接口编程中，重写是子类有自己的逻辑要实现，同时又不破坏已写好程序逻辑的好方法
举个例子，在父类中是public的方法，如果子类中将其降低访问权限为private，那么子类中重写以后的方法对于外部对象就不可访问了，这个就破坏了继承的含义。

2.synchronized

3.正则表达式”\d+\.?\d*”的意义是？
\d+ 表示可以出现1次或是n次数字
\.? 表示可以“.”可以出现一次，也可以不出现
\d* 表示可以出现0次或是n次数字

4.mysql如何避免更新覆盖呢？
1.乐观锁，version。
2.悲观锁
解决方案1（悲观锁）
a.传统的悲观锁法（不推荐）：
在弹出修改工资的页面初始化时（这种情况下一般会去从数据库查询出来），在这个初始化查询中使用select ...for update nowait
通过添加for update nowait语句，将这条记录锁住，避免其他用户更新，从而保证后续的更新是在正确的状态下更新的。
然后在保持这个链接的状态下，在做更新提交。当然这个有个前提就是要保持链接，就是要对链接要占用较长时间，这个在现在web系统高并发高频率下显然是不现实的。
  
b.现在的悲观锁法（推荐优先使用）：
在修改工资这个页面做提交时先查询下，当然这个查询必须也要加锁（select ...for update nowait），有人会说，
在这里做个查询确认记录是否有改变不就行了吗，是的，是要做个确认，只是你不加for update就不能保证你在查询到更新提交这段时间里这条记录没有被其他会话更新过，
所以这种方式也需要在查询时锁定记录，保证在这条记录没有变化的基础上再做更新，若有变化则提示告知用户。
页面做提交时先加锁查询下,不要一开始就加锁，增加效率。

解决方案2（乐观锁）
a.旧值条件（前镜像）法：
就是在sql更新时使用旧的状态值做条件，SQL大致如下 Update table set col1 =newcol1value, col2 = newcol2value….
where col1 =oldcol1value and col2 = oldcol2value….，在上面的例子中我们就可以把当前工资作为条件进行更新，
如果这条记录已经被其他会话更新过，则本次更新了0行，这里我们应用系统一般会做个提示告知用户重新查询更新。
这个取哪些旧值作为条件更新视具体系统实际情况而定。（这种方式有可能发生阻塞，
如果应用其他地方使用悲观锁法长时间锁定了这条记录，则本次会话就需要等待，所以使用这种方式时最好统一使用乐观锁法。）

b.使用版本列法（推荐优先使用）：
其实这种方式是一个特殊化的前镜像法，就是不需要使用多个旧值做条件，只需要在表上加一个版本列，这一列可以是NUMBER或DATE/TIMESTAMP列，加这列的作用就是用来记录这条数据的版本（在表设计时一般我们都会给每个表增加一些NUMBER型和DATE型的冗余字段，以便扩展使用，这些冗余字段完全可以作为版本列用），在应用程序中我们每次操作对版本列做维护即可。在更新时我们把上次版本作为条件进行更新。


[]分布式事物的实现方式？


[]库存如何回滚？


spring中bean的作用范围？
singleton	在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。
prototype	每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。在tomcat启动时，@Scope("prototype")不会创建bean,而是在请求来临时，才会创建。也即是启动不报错，后面可能会报错。
request	每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。
session	同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。
application	限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。

数据库设计三范式？
第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。
第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。

http协议与websocket本质区别？
Websocket全双工，http单工
注:什么是单工、半双工、全工通信？ 
信息只能单向传送为单工； 
信息能双向传送但不能同时双向传送称为半双工； 
信息能够同时双向传送则称为全双工。

造成死锁的原因归类？
所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
产生死锁的原因
1.竞争资源
系统中的资源可以分为两类：
可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源
不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等
产生死锁中的竞争资源之一指的是竞争不可剥夺资源
产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
2.进程间推进顺序非法
若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁

死锁产生的4个必要条件
互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

解决死锁的基本方法
预防死锁
资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
2.避免死锁
预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满
意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前
预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否
则，进程等待。其中最具有代表性的避免死锁算法是银行家算法

