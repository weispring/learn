1. 普通队列实现
直接使用Redis的List实现消息队列，只需简单的两个指令lpush和rpop或者rpush和lpop
2. 实时处理
brpop
3. pubsub
Redis的pub/sub也有其缺点，那就是如果消费者下线，生产者的消息会丢失。

4. 延时队列
score代表的是想要执行时间的时间戳，在某个时间将它插入Zset集合中，它变会按照时间戳大小进行排序，也就是对执行时间前后进行排序，这样的话，起一个死循环线程不断地进行取第一个key值，如果当前时间戳大于等于该key值的socre就将它取出来进行消费删除，就可以达到延时执行的目的, 注意不需要遍历整个Zset集合，以免造成性能浪费。


## 性能优化
### redis 性能瓶颈
1.cpu 可能是瓶颈
2.内存（理论上不是问题）
3.网络操作读写性能（网络、带宽）

### 做了那些优化
1.不用http协议，通过自定义的resp协议传输非常少的数据
2.使用resp协议，解析非常快。
3.redis在处理大部分操作的时候时单进程单线程，部分处理功能多进程多线程。rdb操作时fork子线程。
4.大部分的redis用户请求，确实是单线程处理。

带宽
1.Mbps是带宽单位，在“Mbps”单位中的“b”是指“Bit（位）”。带宽是按位来描述的。
2.MB/s为速度单位，在“MB/s”中的“B”是指“Byte（字节）”。因为数据是按字节传输的。

## 问题
1. Redis为什么这么快？
```
1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

```
2. 那么为什么Redis是单线程的？
Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。
既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了
（毕竟采用多线程会有很多麻烦！）。多线程对于内存、带宽限制没有任何作用。

